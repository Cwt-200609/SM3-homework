#include <stdio.h>
#include <stdint.h>
#include <string.h>

// ---------------------- 原SM3算法代码（此处省略，需完整复制原代码）----------------------
// ----------------------------------------------------------------------------------------

// 1. 统计两个哈希值的差异比特数
static int count_diff_bits(const uint8_t hash0[32], const uint8_t hash1[32]) {
    int diff_count = 0;
    for (int i = 0; i < 32; i++) {
        uint8_t xor = hash0[i] ^ hash1[i];  // 异或：不同比特为1
        // 统计xor中1的个数（Brian Kernighan算法）
        while (xor != 0) {
            xor &= xor - 1;
            diff_count++;
        }
    }
    return diff_count;
}

// 2. 翻转输入中指定位置的比特（byte_idx：字节索引，bit_idx：比特索引，0为最低位）
static void flip_one_bit(uint8_t *input, size_t input_len, size_t byte_idx, size_t bit_idx) {
    if (byte_idx >= input_len || bit_idx >= 8) {
        printf("比特翻转参数错误：byte_idx=%zu（最大%d），bit_idx=%zu（最大7）\n", 
               byte_idx, input_len-1, bit_idx);
        return;
    }
    input[byte_idx] ^= (1 << bit_idx);  // 异或1翻转指定比特
}

// 3. 雪崩效应测试主函数（执行5次不同比特翻转）
void avalanche_test() {
    // 原始输入："sm3_avalanche_test_2024"（长度19字节）
    const char *orig_str = "sm3_avalanche_test_2024";
    size_t orig_len = strlen(orig_str);
    uint8_t orig_input[orig_len];
    memcpy(orig_input, orig_str, orig_len);
    
    // 计算原始哈希值H0
    uint8_t H0[32];
    sm3_compute(orig_input, orig_len, H0);
    printf("=== 开始雪崩效应测试 ===\n");
    printf("原始输入：%s（长度：%zu字节）\n", orig_str, orig_len);
    printf("原始哈希H0："); for (int i=0; i<32; i++) printf("%02x", H0[i]); printf("\n");
    printf("标准要求：单次差异比特数≥128，平均≥128\n\n");
    
    // 5次测试的比特翻转位置（可自定义，确保每次位置不同）
    // 格式：{字节索引（0-18），比特索引（0-7）}
    const size_t flip_positions[5][2] = {
        {0, 0},   // 第1字节（索引0）第1比特（索引0，最低位）
        {3, 5},   // 第4字节（索引3）第6比特（索引5）
        {7, 2},   // 第8字节（索引7）第3比特（索引2）
        {12, 7},  // 第13字节（索引12）第8比特（索引7，最高位）
        {18, 4}   // 第19字节（索引18）第5比特（索引4）
    };
    
    int total_diff = 0;  // 总差异比特数，用于计算平均值
    
    // 执行5次测试
    for (int test_idx = 0; test_idx < 5; test_idx++) {
        // 1. 复制原始输入，避免修改原数据
        uint8_t modified_input[orig_len];
        memcpy(modified_input, orig_input, orig_len);
        
        // 2. 提取当前测试的比特翻转位置
        size_t byte_idx = flip_positions[test_idx][0];
        size_t bit_idx = flip_positions[test_idx][1];
        
        // 3. 翻转指定比特，生成修改后输入
        flip_one_bit(modified_input, orig_len, byte_idx, bit_idx);
        
        // 4. 计算修改后输入的哈希值H1
        uint8_t H1[32];
        sm3_compute(modified_input, orig_len, H1);
        
        // 5. 统计差异比特数
        int diff_bits = count_diff_bits(H0, H1);
        total_diff += diff_bits;
        
        // 6. 输出单次测试结果（含详细记录）
        printf("=== 第%d次测试 ===\n", test_idx + 1);
        printf("翻转位置：第%d字节（索引%d）第%d比特（索引%d）\n", 
               byte_idx + 1, byte_idx, bit_idx + 1, bit_idx);
        printf("修改后输入："); 
        for (size_t i=0; i<orig_len; i++) {
            // 仅显示ASCII可打印字符，不可打印字符用十六进制表示
            if (modified_input[i] >= 0x20 && modified_input[i] <= 0x7E) {
                printf("%c", modified_input[i]);
            } else {
                printf("0x%02x", modified_input[i]);
            }
        }
        printf("\n");
        printf("修改后哈希H1："); for (int i=0; i<32; i++) printf("%02x", H1[i]); printf("\n");
        printf("H0与H1差异比特数：%d（%s标准要求）\n\n", 
               diff_bits, (diff_bits >= 128) ? "满足" : "不满足");
    }
    
    // 计算并输出平均值
    double avg_diff = (double)total_diff / 5;
    printf("=== 雪崩效应测试总结 ===\n");
    printf("5次测试平均差异比特数：%.1f\n", avg_diff);
    printf("测试结果：%s标准要求（≥128）\n\n", (avg_diff >= 128) ? "满足" : "不满足");
}

// 测试入口（主函数）
int main() {
    // 1. 执行抗碰撞性测试（10000组随机输入）
    collision_test(10000);
    
    // 2. 执行雪崩效应测试（5次比特翻转）
    avalanche_test();
    
    return 0;
}
